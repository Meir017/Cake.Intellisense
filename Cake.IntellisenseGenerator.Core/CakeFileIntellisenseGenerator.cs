using Cake.Core;
using Cake.Core.Annotations;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace Cake.IntellisenseGenerator.Core
{

    public class CakeFileIntellisenseGenerator
    {
        protected virtual string CakeFileIntellisensePath => $"{Constants.CakeFileIntellisense}.cs";

        public void GenereteIntellisense(string dllsDirectory)
        {
            var assemblies = Directory.GetFiles(dllsDirectory, "**.dll").Select(Assembly.LoadFile).ToArray();

            var classBuilder = new StringBuilder();
            AppendAutoGeneratedHeader(classBuilder);

            AppendClassStart(classBuilder);
            foreach (var assembly in assemblies)
            {
                AppendAssemblyAliases(classBuilder, assembly);
            }
            AppendClassEnd(classBuilder);

            File.WriteAllText(CakeFileIntellisensePath, classBuilder.ToString());
        }

        public static void AppendAssemblyAliases(StringBuilder builder, Assembly assembly)
        {
            foreach (var type in assembly.DefinedTypes.Where(type => type.IsStatic()))
            {
                AppendTypeAliases(builder, type);
            }
        }
        public static void AppendTypeAliases(StringBuilder builder, TypeInfo type)
        {
            var aliases = Utilities.GetCakeAliases(type);
            if (!aliases.Any()) return;

            builder.AppendLine($"#region {type.Name}");
            foreach (var alias in aliases)
            {
                switch (alias.GetCustomAttribute<CakeAliasAttribute>(inherit: true))
                {
                    case CakeMethodAliasAttribute method:
                        AppendMethodSignature(builder, alias);
                        break;
                    case CakePropertyAliasAttribute property:
                        AppendPropertySignature(builder, alias);
                        break;
                    default:
                        break;
                }
            }
            builder.AppendLine("#endregion");
        }
        public static void AppendMethodSignature(StringBuilder builder, MethodInfo alias)
        {
            builder.Append(Constants.AliasesModifier);

            if (alias.ReturnType == typeof(void)) builder.Append($"void ");
            else builder.Append($"{Utilities.GetTypeRepresentation(alias.ReturnType)} ");

            builder.Append(alias.Name);
            if (alias.IsGenericMethod)
            {
                builder
                    .Append("<")
                    .Append(string.Join(", ", alias.GetGenericArguments().Select(arg => arg.Name)))
                    .Append(">");
            }

            builder
                .Append("(")
                .Append(string.Join(", ", alias.GetParameters().Skip(1)
                    .Select(parameter => $"{Utilities.GetParameterRepresentation(parameter)} {parameter.Name}")))
                .Append(")");

            if (alias.IsGenericMethod)
            {
                foreach (var argument in alias.GetGenericArguments())
                {
                    var constraints = argument.GetTypeInfo().ImplementedInterfaces.Select(Utilities.GetTypeRepresentation);
                    if (argument.BaseType != typeof(object) && argument.BaseType != typeof(System.ValueType))
                    {
                        constraints = constraints.Prepend(Utilities.GetTypeRepresentation(argument.BaseType));
                    }

                    if (argument.GenericParameterAttributes.HasFlag(GenericParameterAttributes.NotNullableValueTypeConstraint))
                    {
                        constraints = constraints.Append("struct");
                    }
                    else
                    {
                        if (argument.GenericParameterAttributes.HasFlag(GenericParameterAttributes.ReferenceTypeConstraint))
                        {
                            constraints = constraints.Append("class");
                        }

                        if (argument.GenericParameterAttributes.HasFlag(GenericParameterAttributes.DefaultConstructorConstraint))
                        {
                            constraints = constraints.Append("new()");
                        }
                    }
                    if (!constraints.Any()) continue;

                    builder.Append($" where {argument.Name} : {string.Join(", ", constraints)}");
                }
            }
            builder
                .Append(Constants.ThrowNotSupportedExceptionArrowExpression)
                .AppendLine();
        }
        public static void AppendPropertySignature(StringBuilder builder, MethodInfo alias)
        {
            builder
                .Append(Constants.AliasesModifier)
                .Append(Utilities.GetTypeRepresentation(alias.ReturnType))
                .Append(" ")
                .Append(alias.Name)
                .Append(Constants.ThrowNotSupportedExceptionArrowExpression)
                .AppendLine();
        }

        public static void AppendAutoGeneratedHeader(StringBuilder builder)
        {
            builder.AppendLine("//------------------------------------------------------------------------------")
                .AppendLine("// <auto-generated>")
                .AppendLine("//     This code was generated by a tool.")
                .AppendLine("//")
                .AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if")
                .AppendLine("//     the code is regenerated. ")
                .AppendLine("// </auto-generated>")
                .AppendLine("//------------------------------------------------------------------------------")
                .AppendLine();
        }
        public static void AppendClassStart(StringBuilder builder)
        {
            builder
                .AppendLine($"namespace {typeof(CakeFile).Namespace}")
                .AppendLine("{")
                .AppendLine($"\tpublic abstract partial class {Constants.CakeFileIntellisense} : {nameof(CakeFile)}")
                .AppendLine("\t{");
        }
        public static void AppendClassEnd(StringBuilder builder)
        {
            builder
                .AppendLine("\t}")
                .AppendLine("}");
        }
    }
}
