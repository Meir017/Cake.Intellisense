using Cake.Core;
using Cake.Core.Annotations;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace Cake.IntellisenseGenerator.Core
{
    public class CakeFileIntellisenseGenerator
    {
        public static readonly string ThrowNotSupportedExceptionArrowExpression = " => throw new System.NotSupportedException();";
        public static readonly string AliasesModifier = "\t\tprotected ";

        protected virtual string CakeFileIntellisensePath => $"{nameof(CakeFileIntellisense)}.cs";

        public void GenereteIntellisense(string dllsDirectory)
        {
            var assemblies = Directory.GetFiles(dllsDirectory, "**.dll").Select(Assembly.LoadFile).ToArray();

            var classBuilder = new StringBuilder();
            AppendAutoGeneratedHeader(classBuilder);

            AppendClassStart(classBuilder);
            foreach (var assembly in assemblies)
            {
                AppendAssemblyAliases(classBuilder, assembly);
            }
            AppendClassEnd(classBuilder);

            File.WriteAllText(CakeFileIntellisensePath, classBuilder.ToString());
        }

        public static void AppendAssemblyAliases(StringBuilder builder, Assembly assembly)
        {
            foreach (var type in assembly.DefinedTypes.Where(type => type.IsStatic()))
            {
                AppendTypeAliases(builder, type);
            }
        }
        public static void AppendTypeAliases(StringBuilder builder, TypeInfo type)
        {
            var aliases = Utilities.GetCakeAliases(type);
            if (!aliases.Any()) return;

            builder.AppendLine($"#region {type.Name}");
            foreach (var alias in aliases)
            {
                switch (alias.GetCustomAttribute<CakeAliasAttribute>(inherit: true))
                {
                    case CakeMethodAliasAttribute method:
                        AppendMethodSignature(builder, alias);
                        break;
                    case CakePropertyAliasAttribute property:
                        AppendPropertySignature(builder, alias);
                        break;
                    default:
                        break;
                }
            }
            builder.AppendLine("#endregion");
        }
        public static void AppendMethodSignature(StringBuilder builder, MethodInfo alias)
        {
            builder.Append(AliasesModifier);

            if (alias.ReturnType == typeof(void)) builder.Append($"void ");
            else if (alias.ReturnType.IsGenericParameter) builder.Append($"{alias.ReturnType} ");
            else builder.Append($"{Utilities.GetTypeRepresentation(alias.ReturnType)} ");

            builder.Append(alias.Name);
            if (alias.IsGenericMethod)
            {
                builder
                    .Append("<")
                    .Append(string.Join(", ", alias.GetGenericArguments().Select(arg => arg.Name)))
                    .Append(">");
            }

            builder
                .Append("(")
                .Append(string.Join(", ", alias.GetParameters().Skip(1)
                    .Select(parameter => $"{Utilities.GetParameterRepresentation(parameter)} {parameter.Name}")))
                .Append(")")
                .Append(ThrowNotSupportedExceptionArrowExpression)
                .AppendLine();
        }
        public static void AppendPropertySignature(StringBuilder builder, MethodInfo alias)
        {
            builder
                .Append(AliasesModifier)
                .Append(Utilities.GetTypeRepresentation(alias.ReturnType))
                .Append(" ")
                .Append(alias.Name)
                .Append(ThrowNotSupportedExceptionArrowExpression)
                .AppendLine();
        }

        public static void AppendAutoGeneratedHeader(StringBuilder builder)
        {
            builder.AppendLine("//------------------------------------------------------------------------------")
                .AppendLine("// <auto-generated>")
                .AppendLine("//     This code was generated by a tool.")
                .AppendLine("//")
                .AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if")
                .AppendLine("//     the code is regenerated. ")
                .AppendLine("// </auto-generated>")
                .AppendLine("//------------------------------------------------------------------------------")
                .AppendLine();
        }
        public static void AppendClassStart(StringBuilder builder)
        {
            builder
                .AppendLine($"namespace {typeof(CakeFile).Namespace}")
                .AppendLine("{")
                .AppendLine($"\tpublic abstract partial class {nameof(CakeFileIntellisense)} : {nameof(CakeFile)}")
                .AppendLine("\t{");
        }
        public static void AppendClassEnd(StringBuilder builder)
        {
            builder
                .AppendLine("\t}")
                .AppendLine("}");
        }
    }
}
